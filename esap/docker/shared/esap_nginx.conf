

# nginx configuration for esap
# note how this connects directly into the esap_api container on port 8000, 
# this is made possible by the docker-compose 'network:' configuration.

upstream web8000 {
  server esap_api:8000;
}


server {
  server_name localhost;

  # inside the container, listen to port 80
  listen 80;
 
  root /shared/public_html;
     
#  location / {
#	# nv: force everybody to esap-gui for the moment ;-)
#	try_files $uri $uri/ /esap-gui/index.html;

  location /esap-gui/ {
    # proxy_pass http://web8017/;

	proxy_set_header Host $host;
	proxy_set_header X-Forwarded-For $remote_addr;
	proxy_intercept_errors on;
	recursive_error_pages on;
    error_page 404 = @fallback;
  }

  # Construction makes it possible to have a 'try_files' combined with a 'proxy_pass'
  # So when a request like "http://raspiastro/astroview/collections" fails, because 'collections' is not a backend location,
  # then the 'error_page' forwards it to a 'try_files', which forwards it to the astroview frontend. (where the 'collections' route is defined).

  location @fallback {
    try_files $uri $uri/ /esap-gui/index.html;
  }

  # ===== proxy to esap-api on port 8000 =====
  location /esap-api/ {
     proxy_pass http://web8000/esap-api/;
     proxy_set_header Host sdc.astron.nl;
	 proxy_set_header X-Forwarded-For $remote_addr;
  }
  
  # This reflects a change in the Django settings to serve multiple applications: STATIC_URL = '/static_esap/'
  location /static_esap/ {
     proxy_pass http://web8000/static_esap/;
	 proxy_set_header Host sdc.astron.nl;
	 proxy_set_header X-Forwarded-For $remote_addr;	 
  }

  
  location /oidc/ {
     proxy_pass http://web8000/oidc/;
  }

  
  location /static/ {
        alias /static/;
  }

  
  # redirect server error pages to the static page /50x.html
  #
  error_page   500 502 503 504  /50x.html;
  location = /50x.html {
      root   /usr/share/nginx/html;
  }

}

