

# nginx configuration for esap
# note how this connects directly into the esap_api container on port 8000,
# this is made possible by the docker-compose 'network:' configuration.

upstream backend {
  # note that this is the container name from the docker-compose.yml, and it uses the internal port because we are on a docker network
  server esap_api:8000;
}

#upstream frontend {
#  # note that this is the container name from the docker-compose-query.yml, and it uses the internal port because we are on a docker network
#  server esap-gui:80;
#}

server {
  server_name localhost;

  # inside the container, listen to port 80
  listen 80;

  root /shared/public_html;

  # ===== adex-gui (frontend) configuration =====
  location /adex-gui/ {
	try_files $uri $uri/ /adex-gui/index.html;
  }

  # ===== esap-gui (frontend) configuration =====
  location /esap-gui/ {
	try_files $uri $uri/ /esap-gui/index.html;
  }

  # ===== react-aladin (frontend) configuration =====
  location /react-aladin/ {
	try_files $uri $uri/ /react-aladin/index.html;
  }

  # ===== exoplanets (frontend) configuration =====
  location /exoplanets/ {
	try_files $uri $uri/ /exoplanets/index.html;
  }

#  location /esap-gui/ {
#    proxy_pass http://frontend/;
#
#	proxy_set_header Host $host;
#	proxy_set_header X-Forwarded-For $remote_addr;
#	proxy_intercept_errors on;
#	recursive_error_pages on;
#   error_page 404 = @fallback;
#  }

  # This construction makes it possible to have a 'try_files' combined with a 'proxy_pass'.
  # So when a request like "http://sdc.astron.nl/esap-gui/vo-query" fails, because 'vo-query' is not a backend location,
  # then the 'error_page' forwards it to a 'try_files', which forwards it to the esap-gui frontend. (where the 'vo-query' route is defined).

#  location @fallback {
#    try_files $uri $uri/ /esap-gui/index.html;
#  }


  # proxy the /static/ url to the frontend container
  location /static/ {
	 # this proxies all calls to /static/ into the frontend container
     #proxy_pass http://frontend/static/;

	 # this proxies all calls to /static/ to the shared static directory (in case of multiple frontends)
	 alias /static/;
  }

# ===== esap-api (backend) configuration =====
# outcomment this section when frontend connects to ':5555/esap-api' instead of to '/esap-api'
#  location /esap-api/ {
#     proxy_pass http://backend/esap-api/;
#     proxy_set_header Host sdc.astron.nl;
#	 proxy_set_header X-Forwarded-For $remote_addr;
#	 proxy_set_header Access-Control-Allow-Origin *
#  }

  # This reflects the Django settings to serve multiple applications: STATIC_URL = '/static_esap/'
  location /static_esap/ {
     proxy_pass http://backend/static_esap/;
	 proxy_set_header Host sdc.astron.nl;
	 proxy_set_header X-Forwarded-For $remote_addr;
  }


  location /oidc/ {
     proxy_pass http://backend/oidc/;
  }



  # redirect server error pages to the static page /50x.html
  #
  error_page   500 502 503 504  /50x.html;
  location = /50x.html {
      root   /usr/share/nginx/html;
  }

}

